import json
import traceback
from typing import Any, Type

from channels.generic.websocket import JsonWebsocketConsumer
from numpy import float32
from rosidl_runtime_py.convert import message_to_ordereddict
from rclpy.executors import MultiThreadedExecutor

import rclpy
import tf2_ros
import asyncio
import threading

from tf2_ros.buffer import Buffer
from lie import SE3
from backend.drive_controls import send_joystick_twist, send_controller_twist
from backend.input import DeviceInputs
from backend.ra_controls import send_ra_controls
from backend.sa_controls import send_sa_controls
from backend.mast_controls import send_mast_controls
from backend.waypoints import (
    get_auton_waypoint_list,
    get_basic_waypoint_list,
    get_current_auton_course,
    get_current_basic_course,
    save_auton_waypoint_list,
    save_basic_waypoint_list,
    save_current_auton_course,
    save_current_basic_course,
    delete_auton_waypoint_from_course
)
from geometry_msgs.msg import Twist, Vector3
from sensor_msgs.msg import NavSatFix, Temperature, RelativeHumidity, JointState
from mrover.msg import (
    Throttle,
    IK,
    ControllerState,
    LED,
    StateMachineStateUpdate,
    GPSWaypoint,
    WaypointType,
    HeaterData,
    ScienceThermistors,
    Oxygen,
    Methane,
    UV,
)
from mrover.srv import (
    EnableAuton, 
    EnableBool,
    ServoSetPos 
)
from std_srvs.srv import SetBool
from std_msgs.msg import Float32

LOCALIZATION_INFO_HZ = 10

cur_ra_mode: str = "disabled"
cur_sa_mode: str = "disabled"
heater_names: list[str] = ["a0", "a1", "b0", "b1"]


class SAConsumer(JsonWebsocketConsumer):
    subscribers = []
    timers = []

    def connect(self) -> None:
        self.accept()

        # Initialize ROS node **before** spinning
        self.ros_context = rclpy.Context()
        self.ros_context.init()
        self.node = rclpy.create_node("teleop_sa")

        self.ros_thread = threading.Thread(target=self.ros_spin, daemon=True)
        self.ros_thread.start()

        # Forwards ROS topic to GUI
        self.forward_ros_topic("/drive_left_controller_data", ControllerState, "drive_left_state")
        self.forward_ros_topic("/drive_right_controller_data", ControllerState, "drive_right_state")
        self.forward_ros_topic("/led", LED, "led")
        self.forward_ros_topic("/nav_state", StateMachineStateUpdate, "nav_state")
        self.forward_ros_topic("/gps/fix", NavSatFix, "gps_fix")
        self.forward_ros_topic("/science_thermistors", ScienceThermistors, "thermistors")
        self.forward_ros_topic("/science_heater_state", HeaterData, "heater_states")
        self.forward_ros_topic("/science_oxygen_data", Oxygen, "oxygen")
        self.forward_ros_topic("/science_methane_data", Methane, "methane")
        self.forward_ros_topic("/science_uv_data", UV, "uv")
        self.forward_ros_topic("/science_temperature_data", Temperature, "temperature")
        self.forward_ros_topic("/science_humidity_data", RelativeHumidity, "humidity")

        self.forward_ros_topic("/arm_controller_state", ControllerState, "arm_state")
        self.forward_ros_topic("/arm_joint_data", JointState, "fk")
        self.forward_ros_topic("/drive_controller_data", ControllerState, "drive_state")
        self.forward_ros_topic("/sa_controller_state", ControllerState, "sa_state")
        self.forward_ros_topic("/sa_gear_diff_position", Float32, "hexhub_site")
        self.forward_ros_topic("basestation/position", NavSatFix, "basestation_position")

        # Services
        self.enable_teleop_srv = self.node.create_client(SetBool, "/enable_teleop")
        self.enable_auton_srv = self.node.create_client(EnableAuton, "/enable_auton")
        self.gear_diff_set_pos_srv = self.node.create_client(ServoSetPos, "/sa_gear_diff_set_position")
        self.auto_shutoff_service = self.node.create_client(EnableBool, "/science_change_heater_auto_shutoff_state")
        self.sa_enable_switch_srv = self.node.create_client(EnableBool, "/sa_enable_limit_switch_sensor_actuator")

        self.heater_services = []
        self.white_leds_services = []
        for name in heater_names:
            self.heater_services.append(self.node.create_client(EnableBool, "/science_enable_heater_" + name))
        for site in ["a", "b"]:
            self.white_leds_services.append(self.node.create_client(EnableBool, "/science_enable_white_led_" + site))

    def disconnect(self, close_code) -> None:
        for subscriber in self.subscribers:
            self.node.destroy_subscription(subscriber)

        if self.ros_context:
            self.ros_context.shutdown()  # This unblocks rclpy.spin()
        self.node.destroy_node()  # Clean up node
        self.node = None  # Clear reference

    def ros_spin(self):
        executor = MultiThreadedExecutor()
        executor.add_node(self.node)

        try:
            executor.spin()  # Allows multiple threads to handle ROS callbacks safely
        except Exception as e:
            print(f"Exception in ROS spin: {e}")
        finally:
            self.node.destroy_node()

    def forward_ros_topic(self, topic_name: str, topic_type: Type, gui_msg_type: str) -> None:
        """
        Subscribes to a ROS topic and forwards messages to the GUI as JSON

        @param topic_name:      ROS topic name
        @param topic_type:      ROS message type
        @param gui_msg_type:    String to identify the message type in the GUI
        """

        def callback(ros_message: Any):
            self.send_message_as_json({"type": gui_msg_type, **message_to_ordereddict(ros_message)})

        self.subscribers.append(self.node.create_subscription(topic_type, topic_name, callback, qos_profile=1))

    def send_message_as_json(self, msg: dict):
        try:
            self.send(text_data=json.dumps(msg))
        except Exception as e:
            self.node.get_logger().warning(f"Failed to send message: {e}")

    def receive(self, text_data=None, bytes_data=None, **kwargs) -> None:
        """
        Callback function when a message is received in the Websocket

        @param text_data:   Stringfied JSON message
        """

        global cur_ra_mode
        global cur_sa_mode

        if text_data is None:
            self.node.get_logger().warning("Expecting text but received binary on GUI websocket...")

        try:
            message = json.loads(text_data)
        except json.JSONDecodeError as e:
            self.node.get_logger().warning(f"Failed to decode JSON: {e}")

        try:
            match message:
                # sending controls
                case {
                    "type": "joystick" | "mast_keyboard" | "ra_controller",
                    "axes": axes,
                    "buttons": buttons,
                }:
                    device_input = DeviceInputs(axes, buttons)
                    match message["type"]:
                        case "joystick":
                            send_joystick_twist(device_input, self.joystick_twist_pub)
                        case "ra_controller":
                            send_controller_twist(device_input, self.controller_twist_pub)
                            send_ra_controls(
                                cur_ra_mode,
                                device_input,
                                self.node,
                                self.thr_pub,
                                self.ee_pos_pub,
                                self.ee_vel_pub,
                                self.buffer,
                            )
                        case "mast_keyboard":
                            send_mast_controls(device_input, self.mast_gimbal_pub)
                            
                case {
                    "type": "ra_mode",
                    "mode": ra_mode,
                }:
                    cur_ra_mode = ra_mode

                case {
                    "type": "sa_controller",
                    "axes": axes,
                    "buttons": buttons,
                    "site": site
                }:
                    device_input = DeviceInputs(axes, buttons)
                    if(site == 0):
                        send_sa_controls(cur_sa_mode, 0, device_input, self.sa_thr_pub)
                    elif(site == 1):
                        send_sa_controls(cur_sa_mode, 1, device_input, self.sa_thr_pub)
                    else:
                        self.node.get_logger().warning(f"Unhandled Site: {site}")

                case {
                    "type": "sa_mode",
                    "mode": mode,
                }:
                    cur_sa_mode = mode

                case {"type": "auton_enable", "enabled": enabled, "waypoints": waypoints}:
                    self.send_auton_command(waypoints, enabled)

                case {"type": "teleop_enable", "enabled": enabled}:
                    self.enable_teleop_srv.call(SetBool.Request(data=enabled))

                case {
                    "type": "save_auton_waypoint_list",
                    "data": waypoints,
                }:
                    save_auton_waypoint_list(waypoints)

                case {
                    "type": "save_basic_waypoint_list",
                    "data": waypoints,
                }:
                    save_basic_waypoint_list(waypoints)

                # case {
                #     "type": "save_current_auton_course",
                #     "data": waypoints
                # }:
                #     node.get_logger().info(f"saving waypoints in course: {waypoints}")
                #     save_current_auton_course(waypoints)

                # case {
                #     "type": "save_current_basic_course",
                #     "data": waypoints                  
                # }:
                #     save_current_basic_course(waypoints)

                # case {
                #     "type": "delete_auton_waypoint_from_course",
                #     "data": waypoint
                # }:
                #     node.get_logger().info(f"deleting waypoint in course: {waypoint}")
                #     delete_auton_waypoint_from_course(waypoint)

                case {
                    "type": "get_basic_waypoint_list",
                }:
                    self.send_message_as_json({"type": "get_basic_waypoint_list", "data": get_basic_waypoint_list()})

                case {
                    "type": "get_auton_waypoint_list",
                }:
                    self.send_message_as_json({"type": "get_auton_waypoint_list", "data": get_auton_waypoint_list()})

                # case {
                #     "type": "get_current_basic_course"
                # }:
                #     self.send_message_as_json({"type": "get_auton_waypoint_list", "data": get_current_basic_course()})

                # case {
                #     "type": "get_current_auton_course"
                # }:
                #     node.get_logger().info(f"current waypoints in course: {get_current_auton_course()}")
                #     self.send_message_as_json({"type": "get_current_auton_course", "data": get_current_auton_course()})

                case {
                    "type": "heater_enable", "enable": e, "heater": heater
                }:
                    self.heater_services[heater_names.index(heater)].call(EnableBool.Request(enable=e))

                case {
                    "type": "set_gear_diff_pos",
                    "position": position,
                    "isCCW": isCCW,
                }:
                    self.gear_diff_set_pos_srv.call(ServoSetPos.Request(position=float(position), is_counterclockwise=isCCW))

                case {
                    "type": "auto_shutoff", 
                    "shutoff": shutoff
                }:
                    self.auto_shutoff_service.call(EnableBool.Request(enable=shutoff))

                case {
                    "type": "white_leds", 
                    "site": site, 
                    "enable": e
                }:
                    self.white_leds_services[site].call(EnableBool.Request(enable=e))

                case {
                    "type": "ls_toggle", 
                    "enable": e
                }:
                    self.sa_enable_switch_srv.call(EnableBool.Request(enable=e))

                case _:
                    self.node.get_logger().warning(f"Unhandled message: {message}")
        except:
            self.node.get_logger().error(f"Failed to handle message: {message}")
            self.node.get_logger().error(traceback.format_exc())